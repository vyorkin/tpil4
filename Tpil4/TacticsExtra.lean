import Mathlib

-- Полезные ссылки:
--
-- https://leanprover.github.io/reference/tactics.html
--
-- В этой части рассмотрим несколько новых тактик, которые мы не обсуждали,
-- но которые тем не менее встречаются не так редко, чтобы их можно было бы
-- игнорировать. Я пробовал их игнорировать - у меня не получилось.
-- Про старые тоже напишем заметки.

-- rfl (reflexivity) и пруф-терм rfl

-- Тактика rfl (reflexivity) фактически разворачивает определение сложения,
-- редуцирует пока редуцируется и проверяет равны ли обе стороны равенства.
-- Это называется равенство по определению.
-- И есть ещё аналогичный пруф-терм, который называется так же - rfl.
-- Когда линь его видит, он делает ровно тоже самое, что и
-- при использовании тактики rfl. Поэтому ты можешь использовать
-- или этот пруф-терм или тактику rfl для доказательства равенств вида:
example (a b : ℝ) : a - b = a + -b := rfl
example (a b : ℝ) : a - b = a + -b := by rfl

-- norm_num
--
-- Вычисляет числовые выражения в целях и гипотезах и сводит задачу к
-- проверке равенства/неравенства двух нормализованных чисел.

-- Что делает:
--
-- Поддерживает операции +, -, *, /, ⁻¹, ^, % над типами вроде ℕ, ℤ, ℚ, ℝ, ℂ и
-- некоторыми абстрактными кольцами/полями. Может доказывать цели вида:
-- A = B, A ≠ B, A < B, A ≤ B, если A и B — числовые выражения.​
--
-- Умеет использовать simp как движок обхода терма: она проходит по выражению,
-- нормализует числа, подставляет значения простых функций, и пытается закрыть цель.​
--
-- Тактика расширяема через атрибут @[norm_num]: можно дописывать свои
-- обработчики для функций вроде Nat.prime, Nat.minFac, Nat.factors и т.п.
--
-- Интуитивно эта тактика "арифметический движок", который
-- пытается свести всё к буквальным числам и сравнить их.

example : (2 : ℝ) + 2 = 4 := by norm_num
example : (12345.2 : ℝ) ≠ 12345.3 := by norm_num
-- example : 123456789 + 987654321 = 1111111110 := by norm_num
example (R : Type*) [Ring R] : (2 : R) + 2 = 4 := by norm_num
example (F : Type*) [LinearOrderedField F] : (2 : F) + 2 < 5 := by norm_num
-- example : Nat.Prime (2^13 - 1) := by norm_num
-- example : ¬ Nat.Prime (2^11 - 1) := by norm_num


-- solve_by_elim

-- Автоматически решает цель, последовательно примененяя (apply) подходящие
-- гипотезы или леммы из локального контекста, с рекурсивным разбором подцелей до
-- полной элиминации (с ограничением глубины в 6 шагов по умолчанию).

-- Основной механизм:
--
-- Тактика начинает с apply на главной цели, подбирая гипотезу, чьё следствие (концовка)
-- совпадает с целью, затем рекурсивно применяет те же правила к сгенерированным подцелям.
-- Если ветвь не доказывается, происходит бэктрэкинг/откат для поиска альтернативного пути.
-- По умолчанию использует локальный контекст плюс стандартные тактики:
-- rfl (рефлекс), trivial, congrFun и congrArg. Цель либо полностью решается, либо фейлится.

-- Рассмотрим несколько примеров:

-- a) Прямое использование единственной гипотезы из контекста:
example (P Q : Prop) (h : P) : P := by solve_by_elim
-- ^ Здесь цель P, в контексте есть гипотеза h : P,
-- тактика просто делает apply h и цель закрывается сразу.

-- b) Несколько шагов применения:
example (P Q : Prop) (h₁ : P → Q) (h₂ : Q → False) (h₃ : P) : False := by solve_by_elim
-- ^
-- Тут цель False.
-- В контексте есть цепочка: P → Q, Q → False и факт P.
--
-- solve_by_elim будет по сути делать apply h₂, затем apply h₁, затем
-- использовать h₃ для финальной подцели, проходя по импликациям и откатываясь при необходимости.

-- c1) Работа с only и исключениями:
example (P Q R : Prop)
        (h₁ : P → Q)
        (h₂ : Q → R)
        (h₃ : P)
        (h_bad : R → False) : R := by
  solve_by_elim only [h₂, h₁, h₃]
-- ^
-- Такой, немного надуманный пример, потому что по факту тут
-- не требуется использовать only, но тем не менее рассмотрим его.
-- По умолчанию тактика видит и h_bad : R → False, и могла бы
-- увести доказательство в противоречие, если бы цель была False.
-- С only явно даём набор, из которого она строит R: P → Q → R.

-- c2) Альтернатива с "чёрным списком" запрещённых гипотез:
example (P Q R : Prop)
        (h₁ : P → Q)
        (h₂ : Q → R)
        (h₃ : P)
        (h_bad : R → False) : R := by
  solve_by_elim [-h_bad]

-- 2. tauto
--
-- tauto — это "финишная" тактика для пропозиционки:
-- она механически раскидывает (∧, ∨, ↔, ∃) в гипотезах и цели и пытается доказать
-- цель автоматически, пользуясь простыми тактиками вроде rfl и solve_by_elim.​

-- Что именно делает tauto:
--
-- В гипотезах tauto рекурсивно разбивает связки вида
-- p ∧ q, p ∨ q, p ↔ q, ∃ x, P x на более простые куски,
-- добавляя соответствующие гипотезы в контекcт.
--
-- В цели она аналогично разбивает цель вида p ∧ q, p ↔ q или
-- ∃ x, P x на подцели, которые проще автоматом решить.
-- Например, цель P ∧ Q превратится в две цели P и Q,
-- а ∃ x, P x — в задачу "подобрать терм" x и доказать P x для него.

-- Как tauto доказывает цель:
--
-- Когда структура уже максимально разложена, tauto пытается доказать
-- оставшиеся "атомарные" цели с помощью следующих тактик:
--
-- rfl           - Доказывает равенства вида p ↔ p, p = p
-- solve_by_elim - Решает цель, последовательно примененяя подходящие
--                 гипотезы или леммы из локального контекста,
--                 с рекурсивным разбором подцелей до полной элиминации.
--
-- Если после всего этого всё ещё остаются не доказанные цели,
-- тактика падает с ошибкой, а если нет — полностью закрывает цель
-- (поэтому её и называют finishing tactic: либо всё, либо ничего).
--
-- В Lean 3 дефолтный tauto "старался быть интуиционистским":
-- избегал использования аксиом классической логики, вроде закона исключённого третьего,
-- пока это не было явно нужно, и для полноценной классической автоматики
-- использовались тактики tauto!/tautology!
--
-- В Lean 4 версия tauto такой скромности не проявляет:
-- она спокойно использует классические принципы, если они доступны, а если хочется
-- доказать используя только принципы интуиционистской логики, то нужно использовать
-- тактику itauto, который как раз не использует принципы классической логики.

-- Как её воспринимать в практике:
--
-- Ментальная модель:
--
-- tauto - прогони всю пропозициональную кашу, раскидай по ∧/∨/↔/∃ и посмотри,
-- нельзя ли всё добить тривиальными шагами и подстановкой гипотез.

-- Применение:
--
-- Если цель — "что-то логическое без глубокой математики"
-- (игры с булевыми связками, элементарная логика из предпосылок),
-- очень часто вместо ручного intro, cases, constructor и т.п. можно просто
-- написать by tauto и смотреть, проканало ли.

-- Рассмотрим несколько примеров использования - от совсем тривиальных до более "вкусных".

-- Элементарное "поглощение":
example (p q : Prop) : p ∧ q → p := by tauto
-- ^ Здесь tauto просто раскидывает гипотезу p ∧ q на p и q и берёт нужное.

-- Простая симметрия ↔:
example (p q : Prop) : p ∧ q ↔ q ∧ p := by tauto
-- ^ Тактика tauto разбивает цель ↔ на две импликации и в каждой
-- переставляет конъюнкты местами, опять же через разбор ∧.

-- Дистрибутивность ∧ относительно ∨:
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by tauto
-- ^ tauto сама делает cases по q ∨ r и собирает обратно нужные конъюнкции/дизъюнкции.

-- "Обратная дистрибутивность":
example (p q r : Prop) : (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r) := by tauto

-- Квантор существования и конъюнкция:
example (α : Type)
        (P Q : α → Prop) :
        (∃ x, P x ∧ Q x) → (∃ x, P x) ∧ (∃ x, Q x) := by tauto
-- Тактика tauto раскрывает ∃ x, P x ∧ Q x, получает конкретный x и P x, Q x,
-- а потом из них строит два отдельных соотв. утверждения в цели.

example (α : Type)
        (P : α → Prop)
        (a : α) :
        (∀ x, P x) → P a := by tauto
