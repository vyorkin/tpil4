-- Полезные ссылки:
--
-- https://leanprover.github.io/reference/tactics.html
--
-- В этой части рассмотрим несколько новых тактик, которые мы не обсуждали,
-- но которые тем не менее встречаются не так редко, чтобы их можно было бы
-- игнорировать. Я пробовал их игнорировать - у меня не получилось.

-- 1. solve_by_elim

-- Автоматически решает цель, последовательно примененяя (apply) подходящие
-- гипотезы или леммы из локального контекста, с рекурсивным разбором подцелей до
-- полной элиминации (с ограничением глубины в 6 шагов по умолчанию).

-- Основной механизм:
--
-- Тактика начинает с apply на главной цели, подбирая гипотезу, чьё следствие (концовка)
-- совпадает с целью, затем рекурсивно применяет те же правила к сгенерированным подцелям.
-- Если ветвь не доказывается, происходит бэктрэкинг/откат для поиска альтернативного пути.
-- По умолчанию использует локальный контекст плюс стандартные тактики:
-- rfl (рефлекс), trivial, congrFun и congrArg. Цель либо полностью решается, либо фейлится.

-- Рассмотрим несколько примеров:

-- a) Прямое использование единственной гипотезы из контекста:
example (P Q : Prop) (h : P) : P := by solve_by_elim
-- ^ Здесь цель P, в контексте есть гипотеза h : P,
-- тактика просто делает apply h и цель закрывается сразу.

-- b) Несколько шагов применения:
example (P Q : Prop) (h₁ : P → Q) (h₂ : Q → False) (h₃ : P) : False := by solve_by_elim
-- ^
-- Тут цель False.
-- В контексте есть цепочка: P → Q, Q → False и факт P.
--
-- solve_by_elim будет по сути делать apply h₂, затем apply h₁, затем
-- использовать h₃ для финальной подцели, проходя по импликациям и откатываясь при необходимости.

-- c1) Работа с only и исключениями:
example (P Q R : Prop)
        (h₁ : P → Q)
        (h₂ : Q → R)
        (h₃ : P)
        (h_bad : R → False) : R := by
  solve_by_elim only [h₂, h₁, h₃]
-- ^
-- Такой, немного надуманный пример, потому что по факту тут
-- не требуется использовать only, но тем не менее рассмотрим его.
-- По умолчанию тактика видит и h_bad : R → False, и могла бы
-- увести доказательство в противоречие, если бы цель была False.
-- С only явно даём набор, из которого она строит R: P → Q → R.

-- c2) Альтернатива с "чёрным списком" запрещённых гипотез:
example (P Q R : Prop)
        (h₁ : P → Q)
        (h₂ : Q → R)
        (h₃ : P)
        (h_bad : R → False) : R := by
  solve_by_elim [-h_bad]

-- 2. tauto
--
-- tauto — это "финишная" тактика для пропозиционки:
-- она механически раскидывает (∧, ∨, ↔, ∃) в гипотезах и цели и пытается доказать
-- цель автоматически, пользуясь простыми тактиками вроде rfl и solve_by_elim.​

-- Что именно делает tauto:
--
-- В гипотезах tauto рекурсивно разбивает связки вида
-- p ∧ q, p ∨ q, p ↔ q, ∃ x, P x на более простые куски,
-- добавляя соответствующие гипотезы в контекcт.
--
-- В цели она аналогично разбивает цель вида p ∧ q, p ↔ q или
-- ∃ x, P x на подцели, которые проще автоматом решить.
-- Например, цель P ∧ Q превратится в две цели P и Q,
-- а ∃ x, P x — в задачу "подобрать терм" x и доказать P x для него.

-- Как tauto доказывает цель:
--
-- Когда структура уже максимально разложена, tauto пытается доказать
-- оставшиеся "атомарные" цели с помощью следующих тактик:
--
-- rfl           - Доказывает равенства вида p ↔ p, p = p
-- solve_by_elim - Решает цель, последовательно примененяя подходящие
--                 гипотезы или леммы из локального контекста,
--                 с рекурсивным разбором подцелей до полной элиминации.
--
-- Если после всего этого всё ещё остаются не доказанные цели,
-- тактика падает с ошибкой, а если нет — полностью закрывает цель
-- (поэтому её и называют finishing tactic: либо всё, либо ничего).
--
-- В Lean 3 дефолтный tauto "старался быть интуиционистским":
-- избегал использования аксиом классической логики, вроде закона исключённого третьего,
-- пока это не было явно нужно, и для полноценной классической автоматики
-- использовались тактики tauto!/tautology!
--
-- В Lean 4 версия tauto такой скромности не проявляет:
-- она спокойно использует классические принципы, если они доступны, а если хочется
-- доказать используя только принципы интуиционистской логики, то нужно использовать
-- тактику itauto, который как раз не использует принципы классической логики.

-- Как её воспринимать в практике:
--
-- Ментальная модель:
--
-- tauto - прогони всю пропозициональную кашу, раскидай по ∧/∨/↔/∃ и посмотри,
-- нельзя ли всё добить тривиальными шагами и подстановкой гипотез.

-- Применение:
--
-- Если цель — "что-то логическое без глубокой математики"
-- (игры с булевыми связками, элементарная логика из предпосылок),
-- очень часто вместо ручного intro, cases, constructor и т.п. можно просто
-- написать by tauto и смотреть, проканало ли.

-- Рассмотрим несколько примеров использования - от совсем тривиальных до более "вкусных".

example (p q : Prop) : p ∧ q → p := by tauto
